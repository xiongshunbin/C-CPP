#include <iostream>
#include <functional>
using namespace std;

/**
 * lambda表达式:
 *      [capture](params) opt -> ret {body;};
 *      capture: 捕获列表
 *      params： 参数列表
 *      opt: 函数选项，可以忽略
 *      ret: 表示返回值类型，返回值类型后置，编译器可根据函数体自动进行推导
 *      body: 函数体
 **/

/**
 * 1.捕捉列表[]：捕获一定范围内的变量
 *      []  不捕捉任何变量
 *      [&] 捕获外部作用域中所有变量，并作为引用在函数体内使用（按引用捕获）
 *      [=] 捕获外部作用域中所有变量，并作为副本在函数体内使用（按值捕获）
 *          拷贝的副本在匿名函数体内部是只读的
 *      [=, &foo] 按值捕获外部作用域中的所有变量，并按照引用捕获外部变量foo
 *      [bar] 按值捕获bar变量，同时不捕获其他变量
 *      [&bar] 按引用捕获bar变量，同时不捕获其他变量
 *      [this] 捕获当前类中的this指针，在当前的匿名函数中只能使用this对应的类里面的成员变量和成员函数
 *          让lambda表达式拥有和当前类成员函数同样的访问权限
 *          如果已经使用了&或者=，默认添加此选项
 **/

/**
 * 2.参数列表(): 和普通函数的参数列表一样，如果没有参数，参数列表可以省略不写
 *      auto f = [](){return 1;};    // 没有参数，参数列表为空
 *      auto f = []{return 1;};      // 没有参数，参数列表省略不写
**/

/**
 * 3.opt选项，不需要可以省略
 *      mutable: 可以修改按值传递进来的拷贝（注意是能修改拷贝，而不是本身）
 *      exception: 指定函数抛出的异常，如抛出整数类型的异常，可以使用throw()
**/

/**
 * 4.返回值类型： 在C++11中，lambda表达式的返回值是通过返回值类型后置语法来定义的
**/

/**
 * 5.函数体： 函数的实现，这部分不能省略，但函数体可以为空。
**/

void func(int x, int y)
{
    int a;
    int b;
    [&]() {
        int c = a;
        int d = x;
    };
    int n = 0;
}

int main()
{

    return 0;
}